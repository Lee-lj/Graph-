在图结构中，存储可以认为是一个立体的图形，由多个的顶点组成(顶点相当于节点，但是图结构中的节点必须叫做顶点Vertex)
顶点直接相互联系的线叫做边edge，例如存储人的人际关系，每个人都可以视为一个顶点，认识就相互连接起来，一个顶点可以连接多个顶点
                   邻接的概念:如果两个顶点之间只用一条边就能连通，就认为这两个顶点是邻接的
                   路径:从一个顶点出发，到达另一个顶点所经过的节点的信息
                   有向图和无向图:有向图是顶点之间的边带有箭头，只能顺着箭头才能到达连接的另一个顶点，但是逆着箭头不能达到这个有向边的起始位置，是单向的
                                                  无向图的边没有箭头，是可以进行双向访问的 
                   带权图:给顶点之间相互连接的边加上一个有意义的数据，例如AB之间的边为2，可以看作从A到B要2时长
                   
                  图结构的存储:通常使用数组，虽然链表可以实现一个数据指向另一个数据，但是在图结构中，这个数据要指向的数据的个数不确定，所以不好使用链表
                                             使用数组来对数据进行存储{比如数据为A,B,C,D,E}先存放在数组中，然后单独使用别的方法来存储数据之间的邻接或者连通关系
                            
                            D                 
                            |        
                                     假设连接关系如下图:C--B--E   
                          \ |     这是个无向图，AC之间也连同了
                            A                                      
                                             
                                                                这种存储顶点之间关系的方式分为:1.邻接表:相当于路径的集合。先从A点开始，将A点能到达的顶点的路径全部列出，如ABC,ABCE等等，
                                                                                                                                                      然后列出B的列出C的等等，直到所有数据全部列出路径，这个路径的列出还是使用链表的，比如ABC，A添加之后指向B，B指向C
                                          
                                          2.邻接矩阵:建立一张表来表示两个顶点之间是否是通的。例如
                                             0和1表示两个顶点之间是否直接连通(间接连通不算连通)
                                           A  B  C  D  E                                                                                                            
                                        A  1  1  1  0  0
                                        B  1  1  1  1  1
                                        C  1  1  1  0  0
                                        D  0  1  0  1  0  
                                        E  0  1  0  0  1
                      
                       图的遍历(两种遍历方式):1.深度优先搜索算法
                                                                                      简单来说就是先查找A，然后查找A的邻接顶点，例如查找到了B，然后又查找B的邻接顶点C，然后找C的邻接顶点，但是D,E不通，
                                                                                      就返回B，找寻B的除C外的下个邻接节点D，然后找D的邻接节点，不通，退回B，找B的邻接节点E，直到不通，返回到A，找A的除B外的下一个邻接节点，如此往复  
                                                                                              创建一个栈，比如先查找A的邻接节点，得到B，查找B的邻接顶点得到C，c查找完分析无邻接顶点，此时将栈中的C弹出栈，又从A-B开始
                                                                                              找B的除C外的邻接节点，然后弹出。通过栈的先进后出，实现A-B-C回退到A-B，直到将B的邻接节点全部走过，弹出B，
                                                                                              找A的除B的邻接节点C，查找，弹出，直到将A的邻接节点全部走过，将A弹出，将B送入栈                                                       
                                                                                                
                        2.广度优先搜索算法
                                                                                      先找顶点A，A找到下一个邻接顶点B，将A-B先存下，再找A-C，通的，存下A-C，找A-D,A-E这两个都不通，返回A-B，从B开始
                                                                                      找B-C,B-D,B-E,这时三个路都通，从A-B-C开始找，直到没有通路，返回A-B-D查找，然后A-B-E。查完后A-B就结束了，开始查找A-C，如此往复 
                                                                                      
                                                                                      和深度优先相似，但是广度优先使用队列来实现顺序查找，从出队方向找邻接顶点，先是A，找到A-B，存起来，接下来继续找A的邻接节点A-C，接下来A没邻接节点，
                                                                                      弹出A，从B开始找邻接节点，C已经访问(用一个变量表示是否访问过了)过了，访问D,E,然后弹出B，从C开始访问未标识的邻接节点，如此往复